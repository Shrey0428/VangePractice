<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Vangelico Block Hack — Practice</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  :root {
    --gap: 6px;
    --bg: #0b0f14;
    --panel: #121821;
    --grid: #0d131b;
    --line: #1f2937;
    --text: #e8f1ff;
    --accent: #3ee4ff;
  }
  * { box-sizing: border-box; font-family: system-ui,Segoe UI,Roboto,Arial }
  body {
    margin: 0;
    background: radial-gradient(1200px 600px at 10% -10%, #0f2030 0%, #0b0f14 60%, #0a0d12 100%);
    color: var(--text);
    display: flex;
    min-height: 100vh;
    align-items: center;
    justify-content: center;
    padding: 18px;
  }
  .wrap { width: 100%; max-width: 860px }
  .panel {
    background: var(--panel);
    padding: 14px;
    border: 1px solid var(--line);
    border-radius: 12px;
    box-shadow: 0 8px 24px rgba(0,0,0,.35);
  }
  h1 { margin: 0 0 10px; font-size: 18px }
  .controls { display: flex; gap: 8px; flex-wrap: wrap; margin: 10px 0 12px }
  button, label {
    background: #0e141c;
    color: var(--text);
    border: 1px solid #223042;
    padding: 9px 12px;
    border-radius: 8px;
    cursor: pointer;
  }
  button:hover { border-color: var(--accent) }
  .stats { display: flex; gap: 16px; flex-wrap: wrap; font-size: 14px; opacity: .95; margin-bottom: 10px }
  
  /* Responsive grid */
  .grid {
    width: 100%;
    display: grid;
    grid-template-columns: repeat(11, 1fr);
    gap: var(--gap);
    background: var(--grid);
    border: 1px solid var(--line);
    border-radius: 12px;
    padding: var(--gap);
  }
  .cell {
    aspect-ratio: 1 / 1;
    border-radius: 10px;
    box-shadow: inset 0 0 0 2px #ffffff14, 0 6px 16px rgba(0,0,0,.35);
    transition: transform .06s ease;
  }
  .cell:hover { transform: scale(1.03) }
  .empty {
    background: transparent;
    border: 1px dashed #22304233;
    box-shadow: none;
  }
  .timer.on { color: #9effa7 }
  .timer.off { color: #ffb3b3 }
  .footer { opacity: .6; text-align: center; margin-top: 10px; font-size: 12px }
</style>
</head>
<body>
  <div class="wrap panel">
    <h1>Vangelico Block Hack — Practice</h1>
    <div class="controls">
      <button id="newBoard">New Board</button>
      <button id="undoBtn">Undo</button>
      <label><input type="checkbox" id="timerToggle"> Timer mode</label>
      <button id="resetTimer">Reset Timer</button>
    </div>
    <div class="stats">
      <div>Grid: <b>11×8</b></div>
      <div>Clears: <b id="clears">0</b></div>
      <div>Largest Group: <b id="largest">0</b></div>
      <div>Moves Left: <b id="movesLeft">—</b></div>
      <div>Timer: <b id="timer" class="timer off">00:00</b></div>
    </div>
    <div id="grid" class="grid"></div>
    <div class="footer">Rules: Click groups of 2+ same color (no diagonals). After clears: gravity down, then columns shift left.</div>
  </div>

<script>
(() => {
  const COLS = 11, ROWS = 8, COLORS = ["#ff5e5e", "#5eff8d", "#5eb9ff"];
  const gridEl = document.getElementById('grid');
  const clearsEl = document.getElementById('clears');
  const largestEl = document.getElementById('largest');
  const movesLeftEl = document.getElementById('movesLeft');
  const timerEl = document.getElementById('timer');
  const timerToggle = document.getElementById('timerToggle');
  const resetTimerBtn = document.getElementById('resetTimer');

  let board = [], clears = 0, largest = 0, undoStack = [];
  let timerOn = false, startTime = null, rafId = null;

  function newBoard() {
    board = Array.from({length: ROWS}, () => Array.from({length: COLS}, () => (Math.random()*3|0)));
    undoStack.length = 0;
    clears = 0; largest = 0;
    render();
    updateStats();
    if (timerOn) startTimer(true); else setTimerText(0);
  }

  function copyBoard(src){ return src.map(r => r.slice()); }

  function render() {
    gridEl.innerHTML = '';
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        const v = board[r][c];
        const d = document.createElement('div');
        d.dataset.r = r; d.dataset.c = c;
        d.className = 'cell' + (v==null ? ' empty' : '');
        if (v!=null) d.style.background = COLORS[v];
        d.addEventListener('click', onCellClick);
        gridEl.appendChild(d);
      }
    }
  }

  function onCellClick(e){
    const r = +e.currentTarget.dataset.r, c = +e.currentTarget.dataset.c;
    if (board[r][c] == null) return;
    const group = getGroup(r,c);
    if (group.length < 2) return;

    undoStack.push({ board: copyBoard(board), clears, largest });
    group.forEach(([rr,cc]) => board[rr][cc] = null);
    clears++;
    largest = Math.max(largest, group.length);

    gravityDown();
    shiftLeft();

    render();
    updateStats();

    if (!anyMovesLeft()) {
      const left = remainingTiles();
      setTimeout(() => alert(left===0 ? 'Perfect clear! No tiles left.' : `No moves left. ${left} tiles remain.`), 20);
    }
  }

  function getGroup(sr, sc){
    const target = board[sr][sc];
    if (target == null) return [];
    const seen = new Set([sr+','+sc]);
    const stack = [[sr,sc]];
    while (stack.length){
      const [r,c] = stack.pop();
      for (const [nr,nc] of [[r-1,c],[r+1,c],[r,c-1],[r,c+1]]){
        if (nr<0||nr>=ROWS||nc<0||nc>=COLS) continue;
        if (board[nr][nc]===target){
          const key = nr+','+nc;
          if(!seen.has(key)){ seen.add(key); stack.push([nr,nc]); }
        }
      }
    }
    return Array.from(seen).map(s => s.split(',').map(Number));
  }

  function gravityDown(){
    for (let c=0;c<COLS;c++){
      const col = [];
      for (let r=0;r<ROWS;r++) col.push(board[r][c]);
      const filled = col.filter(v => v!=null);
      const empties = Array(ROWS - filled.length).fill(null);
      const newCol = empties.concat(filled);
      for (let r=0;r<ROWS;r++) board[r][c] = newCol[r];
    }
  }

  function shiftLeft(){
    const nonEmptyCols = [];
    for (let c=0;c<COLS;c++){
      let has = false;
      for (let r=0;r<ROWS;r++){
        if (board[r][c] != null){ has = true; break; }
      }
      if (has) nonEmptyCols.push(c);
    }
    const newBoard = Array.from({length: ROWS}, () => Array(COLS).fill(null));
    let nc = 0;
    for (const c of nonEmptyCols){
      for (let r=0;r<ROWS;r++){
        newBoard[r][nc] = board[r][c];
      }
      nc++;
    }
    board = newBoard;
  }

  function anyMovesLeft(){
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        const v = board[r][c];
        if (v==null) continue;
        if (r+1<ROWS && board[r+1][c]===v) return true;
        if (c+1<COLS && board[r][c+1]===v) return true;
      }
    }
    return false;
  }

  function remainingTiles(){
    let n=0; for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) if (board[r][c]!=null) n++;
    return n;
  }

  function updateStats(){
    clearsEl.textContent = clears;
    largestEl.textContent = largest;
    movesLeftEl.textContent = anyMovesLeft() ? 'Yes' : 'No';
  }

  function undo(){
    const prev = undoStack.pop();
    if (!prev) return;
    board = prev.board;
    clears = prev.clears;
    largest = prev.largest;
    render();
    updateStats();
  }

  function startTimer(reset=false){
    if (reset || startTime==null) startTime = performance.now();
    timerOn = true;
    timerEl.classList.remove('off'); timerEl.classList.add('on');
    if (rafId) cancelAnimationFrame(rafId);
    const tick = (t)=>{
      if (!timerOn) return;
      const ms = t - startTime;
      setTimerText(ms);
      rafId = requestAnimationFrame(tick);
    };
    rafId = requestAnimationFrame(tick);
  }
  function stopTimer(){
    timerOn = false;
    timerEl.classList.remove('on'); timerEl.classList.add('off');
    if (rafId) cancelAnimationFrame(rafId);
  }
  function resetTimer(){
    if (timerOn){ startTimer(true); } else { setTimerText(0); }
  }
  function setTimerText(ms){
    const total = Math.max(0, Math.floor(ms/1000));
    const m = String((total/60|0)).padStart(2,'0');
    const s = String(total%60).padStart(2,'0');
    timerEl.textContent = `${m}:${s}`;
  }

  document.getElementById('newBoard').addEventListener('click', newBoard);
  document.getElementById('undoBtn').addEventListener('click', undo);
  timerToggle.addEventListener('change', (e)=>{
    if (e.target.checked) startTimer(true); else stopTimer();
  });
  resetTimerBtn.addEventListener('click', resetTimer);

  newBoard();
})();
</script>
</body>
</html>
